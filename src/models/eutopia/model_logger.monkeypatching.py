"""
model_logger

depends on dataset and therefore SQLAlchemy

usage:

log = ModelLog("sqlite://") # this can be any SQLAlchemy connection string.
log['



TODO:
* [ ] can metaclass magic D.R.Y. this up?
* [ ] do we really want TimestepLogger to *be* a dataset? Maybe we only want it to wrap one? Or maybe we want it to be one but to disable most of the methods..
    upsert() and update() and drop() and delete() all seem like things that a logger should not be able to do, even by accident.
* [ ] Dataset insists on generating its own id columns, which is really annoying

"""


import functools
def funcdebug(f):
    # decorator which traces function calls
    def ff(*args, **kwargs):
        print("DEBUG: %s(%s, %s)" % (f.__name__, args, kwargs))
        return f(*args, **kwargs)
    ff = functools.wraps(f)(ff)
    return ff


import dataset
import dataset.persistence.database
import sqlalchemy

import uuid #use uuids instead of autoincrementing ids; this requires more storage, but has the advantage that our runs are absolutely uniquely identifiable.


    
class ModelTable(dataset.Table):    
    def insert(self, row, *args, **kwargs):
        row = dict(row) #coerce
        row['run_id'] = self.database.id
        return super().insert(row, *args, **kwargs)
    #TODO: finish wrapping the row-related ops, update(), upsert() etc
    
 
class ModelLog(dataset.Database):
    __table_class__ = ModelTable
    def __init__(self, *args, **kwargs):
        self.id = self.new_id()
        super().__init__(*args, **kwargs)
    
    @staticmethod
    def new_id():
        #generate a new unique id, then clip it to 32bits because SQL can't handle bigints
        return uuid.uuid4().int & 0xFFFFFFFF 

    def get_table(self, *args, **kwargs):        
        #this code monkey-patches dataset to use our table class instead
        #(but it puts it back immediately!)
        #TODO: is there a way to like, clone the whole loaded package and only tweak some bits?

        original = dataset.persistence.database.Table
        try:
            dataset.persistence.database.Table = type(self).__table_class__
            print("MAKING TABLE")
            v = super().get_table(*args, **kwargs)
            print("DONE TBALE")
            #v.drop_column("id") #go away, autogenerated id cruft
            #self.op.drop_column(v.table.name, "id") #<-- this is out, because sqlite doesn't understand ALTER TABLE DROP COLUMN; instead it forces you to recreate the table from scratch, and we really want sqlite to be a debugging and even deployment option
            return v
        finally:
            dataset.persistence.database.Table = original



class TimestepTable(ModelTable):
    def __init__(self, *args, **kwargs):
        print("initing", id(self))
        super().__init__(*args, **kwargs)
        print(self.table.columns.keys())
        self.database.op.add_column(
                     self.table.name,
                     sqlalchemy.Column("timdfe", sqlalchemy.INTEGER,
                                primary_key=True,
                                server_default="0", #sqlite has a quirk: it's idea of a NOT NULl column is one for which it knows a different value to put in its place, not that you cannot insert something null
                                #default=lambda: self.database.time
                                )) #remember, self.database *is* TimestepLog, in this case

            
class TimestepLog(ModelLog):
    __table_class__ = TimestepTable
    def __init__(self, *args, **kwargs):
        self.time = 0
        super().__init__(*args, **kwargs)
    def step(self):
        self.time += 1

    

def connector(db_class):
    def connect(*args, **kwargs):
        original,dataset.Database = dataset.Database, db_class
        try:
            return dataset.connect(*args, **kwargs)
        finally:
            dataset.Database = original
    return connect

time_connect = connector(TimestepLog)
model_connect = connector(ModelLog)

if __name__ == '__main__':
    # tests!
    import random
    q = time_connect("sqlite:///:memory:")
    for t in range(20):
        for farmer in ["frank", "alysha", "barack"]:
            q['myawesometable'].insert({"farmer": farmer, "riches": random.randint(0, 222)})
        q.step()
        
    print(q.tables)
    for row in q['myawesometable'].all():
        print(row)