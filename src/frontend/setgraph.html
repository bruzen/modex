<html>
<head>
<title> Dynamic Linegraph backed by CacheSet [backed by websockets backed by replicate.py backed by a simulation] </title>
</head>

<body>


</body>

<!--

pourover is not at all what I thought it would be
but I can probably work with it, though inefficiently
 the trouble is that pourover is heavily designed around a single use case: dataset drilldown.
  you can construct slices (MatchSets) and it has something it calls views which (using View.setSelection()) you can give particular subsets targets
  but, every view is tied back to the single global set of "filters" (a filter essentially being an parameterized where clause--unapplyed (so e.g. you can have a filter that represents "where $1 in hobbies")), and each filter
 But, I *can* replicate use its filtering 

another irritant: PourOver mutates the objects you give it, attaching a primary key (cid) to each.
 
 i just want to load my data as needed!
 I wonder how erlang handles this

crossfilter is specifically a cross-filter: each crossfilter instance is *one* view; in particular, filtering on any dimension (i.e. object property) filters all the others too, so there's no way
 at doing that one specific thing, though, an updateable view, it is excellent 

lets see if i can get a websocket talking to replicate.py, at least
 make a script that sucks less

-->

<script src="/assets/libs/json2.js"></script>
<script src="/assets/libs/underscore.js"></script>
<script src="/assets/libs/pourover.js"></script>
<script src="/assets/libs/findIndex.js"></script>
<script src="cacheset.js"></script>
<script src="HDRJ.js"></script>
<script>
   
 function HDRJCacheSet(address, set) {  //this should be a mixin onto PourOver.Collection, or maybe it should be the ReplicatorProcess which sits and and you give a PourOver.Collection to at construction
     // XXX BEWARE: in the case that your dataset does not have primary keys on it, duplicate rows are legal, so if you get a message to remove a row you need to be careful to *only remove one*
   
     var self = this;
     
     self.name = name;
     self.collection = set;
     
     var feed = new HDRJ(address);
     self._feed = feed; //mostly for debugging
     
     
     function addItem(row) {
         self.collection.insert(row);
     }
     
     function removeItem(row) {
         // PourOver.Collection.removeItems() deletes by PourOver CID,
         // and so requires items that it has mutated--marked with CIDs--
         // and copied into itself.
         // but the backend doesn't know anything about PourOver CIDs and so cannot possibly provide this
         // The way we handle is madly inefficient:
         //   we do one scan (.find()), and then once the item is found,
         //   internally PourOver does another scan, copying every item except
         //   the unfortunate soul into a new set.
         
         // at this layer we use underscore's expensive isEqual() function because equivalent items coming out of JSON.parse() (which HDRJ does) will not be considered == nor === by javascript.
         var unfortunate_soul = _(self.collection._cache).find(function(g) {
           return _.isEqual(g, row);
         })
         
         if(unfortunate_soul) {
           self.collection.delete(unfortunate_soul);
         }
     }
     
     feed.on("insert", function(row) {
         addItem(row);
         self.trigger("change");  //TODO: tag useful data along with this event
     })
     
     feed.on("update", function(old_row, new_row) {
         removeItem(old_row);
         addItem(new_row);
         self.trigger("change");  //TODO: tag useful data along with this event
     })
     
     feed.on("delete", function(row) {
         removeItem(row);
         self.trigger("change");  //TODO: tag useful data along with this event
     })
     
   }
_.extend(HDRJCacheSet.prototype, PourOver.Events, {
});


// TODO: write HDRJCacheSet as a subclass of cacheset(?)
   

 var films = new CacheSet([]);
 var films_tracker = new HDRJCacheSet("ws://" + location.hostname + ":8081", films);
 films_tracker.on("change", function(evt) {
    console.log("The Films are now ", JSON.stringify(films._cache))
 })
 
 var wheat = new Select(films, ["time", "durumWheatConventional"])
 var organic_wheat = new Select(films, ["time", "durumWheatGreen"])
 
 
/*films_tracker._feed.on("insert", function(e) { console.log("insert", e); })
films_tracker._feed.on("update", function(e) { console.log("update", e); })
films_tracker._feed.on("delete", function(e) { console.log("delete", e); })
 */ 
   
   
   
   
   
</script>

</html>