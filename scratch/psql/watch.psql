-- watch.psql
-- This postgres + pl/python2 script demonstrates watching changes to a table
-- This could be probably done in plpgsql, but I know python better, and it comes with serialization (json, msgpack, pickle) available easily.
-- these tips are from
--  http://www.postgresql.org/message-id/1405660725952-5811931.post@n5.nabble.com and
--  http://www.postgresql.org/message-id/1405703990457-5811982.post@n5.nabble.com
-- The reason I'm not using "Logical Decoding" <http://www.postgresql.org/docs/devel/static/logicaldecoding-example.html> is because it's still in devel---not even Arch Linux, usually full of bleeding edge code, has this feature yet. Plus it requires fiddling with the .conf file, same as replicant.py does, but in an incompatible way.


DROP TABLE IF EXISTS films CASCADE;
CREATE TABLE films (name text, kind text, rating int);
CREATE VIEW comedies AS select * from films where kind = 'Comedy'; --this from <http://www.postgresql.org/docs/current/static/sql-createview.html#SQL-CREATEVIEW-UPDATABLE-VIEWS>


-- other crippling bits: there's no way to set state (except, I suppose, through the DB itself)

CREATE LANGUAGE plpython2u;

-- pl/ rules: each session has a correspond; so, every python script within this SQL script is run by the same interpreter (with the same globals, etc)
--  however, *other* sessions appear to launch *other* interpreters, even though the python code those sessions might end up triggering was set elsewhere.
-- the upshot of this, for us, is that we cannot rely on global variables or even global file descriptors.
-- http://www.postgresql.org/docs/9.3/static/plpython-sharing.html claims "Each function gets its own execution environment" but there's not total separation:

--CREATE FUNCTION fifo_init() RETURNS void AS $$
DO $$
  print GD
  print SD
  global FIFO, FIFO_fd
  if "FIFO" not in globals():
    import sys, os
    globals()['sys'] = sys
    globals()['os'] = os
    #this is our first time running in this instance of the python interpreter:
    # run initializations
    FIFO = "/tmp/_changes"
    try:      
      print("hhmm")
      if os.exists(FIFO):
        #TODO: check that, if it exists, it's a FIFO and we have perms on it
        pass
      else:
        os.mkfifo(FIFO)
    except:
      print("couldn't make %s. ignoring" % FIFO)
      pass
    FIFO_fd = os.open(FIFO, os.O_WRONLY | os.O_NONBLOCK)
    sys.stdout = os.fdopen(FIFO_fd, "w")
$$ language plpython2u;

DROP FUNCTION IF EXISTS watch_table();
--'RETURNS trigger' is postgres speak for "this doesn't actually return a value but it's meant to be used as a trigger callback"
-- the main reference for this function is http://www.postgresql.org/docs/9.3/static/plpython-trigger.html
CREATE FUNCTION watch_table() RETURNS trigger AS $$ 
  # triggers do not have arguments passed
  # instead, pl/python passes the trigger data in global variables
  
  #f.write('butst\n');
  #f.close()
  import json
  print TD["table_name"], #<-- no newline
  if TD["event"] == "INSERT":
    print "+", TD["new"]
  elif TD["event"] == "UPDATE":
    print TD["old"], "-->", TD["new"]
  elif TD["event"] == "DELETE":
    print "-", TD["old"]
  #print json.dumps(TD)
$$ language plpython2u;


CREATE TRIGGER watch_table
  AFTER INSERT OR UPDATE OR DELETE
  ON films 
  FOR EACH ROW
  EXECUTE PROCEDURE watch_table();

-- this one is crippled because watching views doesn't help much
-- 1) triggers on a view only trigger if you actually said "UPDATE comedies SET ... WHERE ... ", not if you do "UPDATE films ..."
-- 2) triggers on a view *must* be "FOR EACH STATEMENT" unless you use "INSTEAD OF" but that would be something very different, then, and make using triggers and views and sql kind of pointless.
--CREATE TRIGGER watch_table
--  AFTER INSERT OR UPDATE OR DELETE
--  ON comedies
--  FOR EACH STATEMENT
--  EXECUTE PROCEDURE watch_table();

\COPY films FROM './films.sql'; -- COPY runs on the server, Hence, the client commanding the server to load a file *must give a full path*, because it doesn't know where the server is. Conversely, \COPY runs on the client, which, if the server is remote, might be a large amount of data. See <https://wiki.postgresql.org/wiki/COPY>

INSERT INTO films VALUES ('Grass', 'Documentary', 0);
INSERT INTO films VALUES ('The Mail Man', 'Documentary', 3);
