
-- these tips are from
--  http://www.postgresql.org/message-id/1405660725952-5811931.post@n5.nabble.com and
--  http://www.postgresql.org/message-id/1405703990457-5811982.post@n5.nabble.com


DROP TABLE IF EXISTS films CASCADE;
CREATE TABLE films (name text, kind text, rating int);
CREATE VIEW comedies AS select * from films where kind = 'Comedy'; --this from <http://www.postgresql.org/docs/current/static/sql-createview.html#SQL-CREATEVIEW-UPDATABLE-VIEWS>


-- is there a way to list all defined triggers? probably by querying the right internal pg_* table..

CREATE TRIGGER watch_table_films
  AFTER INSERT OR UPDATE OR DELETE
  ON films
  FOR EACH ROW
  EXECUTE PROCEDURE watch_table();

-- this one is crippled because watching views doesn't help much
-- 1) triggers on a view only trigger if you actually said "UPDATE comedies SET ... WHERE ... ", not if you do "UPDATE films ..."
-- 2) triggers on a view *must* be "FOR EACH STATEMENT" unless you use "INSTEAD OF" but that would be something very different, then, and make using triggers and views and sql kind of pointless.
--CREATE TRIGGER watch_table_comedies
--  AFTER INSERT OR UPDATE OR DELETE
--  ON comedies
--  FOR EACH STATEMENT
--  EXECUTE PROCEDURE watch_table();

\COPY films FROM './films.sql'; -- COPY runs on the server, Hence, the client commanding the server to load a file *must give a full path*, because it doesn't know where the server is. Conversely, \COPY runs on the client, which, if the server is remote, might be a large amount of data. See <https://wiki.postgresql.org/wiki/COPY>

INSERT INTO films VALUES ('Grass', 'Documentary', 0);
INSERT INTO films VALUES ('The Mail Man', 'Documentary', 3);
DELETE FROM films WHERE name = 'Sallu Sue' or name = 'Seventy Days';
INSERT INTO films VALUES ('Superfly', 'Comedy', 5);
UPDATE films SET name = 'Ugly Ducks' WHERE rating < 5;

DROP MATERIALIZED VIEW IF EXISTS comedies_m;
CREATE MATERIALIZED VIEW comedies_m AS
  SELECT * FROM films WHERE kind = 'Comedy'
  WITH DATA;
--REFRESH MATERIALIZED VIEW comedies_m;

SELECT * FROM films;

-- this is illegal; you can attach triggers only to tables and to views (and views have extra restrictions)
-- 
--CREATE TRIGGER watch_comedies
--  AFTER INSERT OR UPDATE OR DELETE
--  ON comedies_m
--  FOR EACH STATEMENT
--  EXECUTE PROCEDURE watch_table();

-- CREATE TRIGGER watch_table_view
--  AFTER INSERT OR UPDATE OR DELETE
--  ON comedies
--  FOR EACH STATEMENT
--  EXECUTE PROCEDURE watch_table('comedies');

